#include "stm8s_mylib.h"

// static uint8_t u8Time[3] = {0x00, 0x00, 0x00};
static const uint8_t OLED_FONT[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, //   0
	0x00, 0x00, 0x2f, 0x00, 0x00, // ! 1
	0x00, 0x07, 0x00, 0x07, 0x00, // " 2
	0x14, 0x7f, 0x14, 0x7f, 0x14, // # 3
	0x24, 0x2a, 0x7f, 0x2a, 0x12, // $ 4
	0x62, 0x64, 0x08, 0x13, 0x23, // % 5
	0x36, 0x49, 0x55, 0x22, 0x50, // & 6
	0x00, 0x05, 0x03, 0x00, 0x00, // ' 7
	0x00, 0x1c, 0x22, 0x41, 0x00, // ( 8
	0x00, 0x41, 0x22, 0x1c, 0x00, // ) 9
	0x14, 0x08, 0x3E, 0x08, 0x14, // * 10
	0x08, 0x08, 0x3E, 0x08, 0x08, // + 11
	0x00, 0x00, 0xA0, 0x60, 0x00, // , 12
	0x08, 0x08, 0x08, 0x08, 0x08, // - 13
	0x00, 0x60, 0x60, 0x00, 0x00, // . 14
	0x20, 0x10, 0x08, 0x04, 0x02, // / 15
	0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 16
	0x00, 0x42, 0x7F, 0x40, 0x00, // 1 17
	0x42, 0x61, 0x51, 0x49, 0x46, // 2 18
	0x21, 0x41, 0x45, 0x4B, 0x31, // 3 19
	0x18, 0x14, 0x12, 0x7F, 0x10, // 4 20
	0x27, 0x45, 0x45, 0x45, 0x39, // 5 21
	0x3C, 0x4A, 0x49, 0x49, 0x30, // 6 22
	0x01, 0x71, 0x09, 0x05, 0x03, // 7 23
	0x36, 0x49, 0x49, 0x49, 0x36, // 8 24
	0x06, 0x49, 0x49, 0x29, 0x1E, // 9 25
	0x00, 0x36, 0x36, 0x00, 0x00, // : 26
	0x00, 0x56, 0x36, 0x00, 0x00, // ; 27
	0x08, 0x14, 0x22, 0x41, 0x00, // < 28
	0x14, 0x14, 0x14, 0x14, 0x14, // = 29
	0x00, 0x41, 0x22, 0x14, 0x08, // > 30
	0x02, 0x01, 0x51, 0x09, 0x06, // ? 31
	0x32, 0x49, 0x59, 0x51, 0x3E, // @ 32
	0x7C, 0x12, 0x11, 0x12, 0x7C, // A 33
	0x7F, 0x49, 0x49, 0x49, 0x36, // B 34
	0x3E, 0x41, 0x41, 0x41, 0x22, // C 35
	0x7F, 0x41, 0x41, 0x22, 0x1C, // D 36
	0x7F, 0x49, 0x49, 0x49, 0x41, // E 37
	0x7F, 0x09, 0x09, 0x09, 0x01, // F 38
	0x3E, 0x41, 0x49, 0x49, 0x7A, // G 39
	0x7F, 0x08, 0x08, 0x08, 0x7F, // H 40
	0x00, 0x41, 0x7F, 0x41, 0x00, // I 41
	0x20, 0x40, 0x41, 0x3F, 0x01, // J 42
	0x7F, 0x08, 0x14, 0x22, 0x41, // K 43
	0x7F, 0x40, 0x40, 0x40, 0x40, // L 44
	0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 45
	0x7F, 0x04, 0x08, 0x10, 0x7F, // N 46
	0x3E, 0x41, 0x41, 0x41, 0x3E, // O 47
	0x7F, 0x09, 0x09, 0x09, 0x06, // P 48
	0x3E, 0x41, 0x51, 0x21, 0x5E, // Q 49
	0x7F, 0x09, 0x19, 0x29, 0x46, // R 50
	0x46, 0x49, 0x49, 0x49, 0x31, // S 51
	0x01, 0x01, 0x7F, 0x01, 0x01, // T 52
	0x3F, 0x40, 0x40, 0x40, 0x3F, // U 53
	0x1F, 0x20, 0x40, 0x20, 0x1F, // V 54
	0x3F, 0x40, 0x38, 0x40, 0x3F, // W 55
	0x63, 0x14, 0x08, 0x14, 0x63, // X 56
	0x07, 0x08, 0x70, 0x08, 0x07, // Y 57
	0x61, 0x51, 0x49, 0x45, 0x43, // Z 58
	0x00, 0x7F, 0x41, 0x41, 0x00, // [ 59
	0x02, 0x04, 0x08, 0x10, 0x20, // \ 60
	0x00, 0x41, 0x41, 0x7F, 0x00, // ] 61
	0x04, 0x02, 0x01, 0x02, 0x04, // ^ 62
	0x40, 0x40, 0x40, 0x40, 0x40  // _ 63
};
static const uint8_t OLED_FONT_BIG[] ={
    7,5,5,5,7,      //0
    1,1,1,1,1,      //1
    7,1,7,4,7,      //2
    7,1,7,1,7,      //3
    5,5,7,1,1,      //4
    7,4,7,1,7,      //5
    7,4,7,5,7,      //6
    7,5,1,1,1,      //7
    7,5,7,5,7,      //8
    7,5,7,1,7       //9     
};

const unsigned char lacoVietNam [] = {
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x03, 0x00, 0x00,
0x00, 0x00, 0x03, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFB, 0xF3, 0xF3, 0xE3, 0xE3, 0xC3, 0xC3,
0x83, 0x83, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x83, 0x83,
0xC3, 0xC3, 0xE3, 0xE3, 0xF3, 0xF3, 0xFB, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x1C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x1C, 0x7E, 0xFE, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xBF, 0x8F, 0xC3, 0xC0, 0xE0, 0xE0, 0xF0, 0xF8, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF,
0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xE0, 0xC0, 0xC3, 0x8F, 0xBF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

const unsigned char mixigamingLogo [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40,
0x80, 0xC0, 0xE0, 0xE0, 0xD0, 0xC8, 0xE0, 0xE0, 0xF0, 0xC0, 0xC0, 0xF8, 0xF0, 0xF8, 0xFC, 0xF8,
0xFC, 0xFE, 0xFE, 0xFA, 0xFC, 0xF8, 0xE4, 0xF8, 0xE0, 0xE0, 0xC0, 0xF0, 0xC0, 0x80, 0x20, 0x80,
0x80, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xF0, 0xFC, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 0xF0, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x80, 0xE7, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x07, 0x03, 0x01,
0x00, 0x00, 0x00, 0x01, 0x01, 0x83, 0xC3, 0x63, 0x33, 0x37, 0x17, 0x97, 0xF7, 0xF3, 0xE3, 0xE3,
0xC3, 0x83, 0xC3, 0x63, 0x33, 0x1B, 0x09, 0xED, 0xFD, 0xFD, 0xF9, 0xF9, 0x19, 0x71, 0xE1, 0x01,
0x01, 0x01, 0x03, 0x03, 0x07, 0x0F, 0x3F, 0x7F, 0xFF, 0xFF, 0x6E, 0x9C, 0xF8, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0x0F, 0x08, 0x1B, 0xFF, 0x7F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x39, 0x60, 0x60, 0xC0, 0xC0, 0xC3, 0xC7, 0x4F, 0x67, 0x33,
0x3F, 0x7F, 0xC1, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x83, 0xC3, 0xC1, 0x60, 0x38, 0x0F, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x3F, 0xF1, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF0, 0x7F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1C, 0x70, 0xE0, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x0C, 0x00,
0x00, 0x00, 0x00, 0x80, 0xC3, 0xE0, 0x70, 0x38, 0x0E, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07,
0x06, 0x0C, 0x08, 0x18, 0x10, 0x30, 0x30, 0x20, 0x60, 0x60, 0x40, 0x41, 0x41, 0x41, 0x43, 0x42,
0x42, 0x42, 0x42, 0x42, 0x42, 0x62, 0x62, 0x63, 0x21, 0x21, 0x30, 0x10, 0x18, 0x18, 0x08, 0x0C,
0x06, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char levelBAT_full [] = {
0xFF,0x81,0xBD,0xBD,0xBD,0x81,0xBD,0xBD,0xBD,0x81,0xBD,0xBD,0xBD,0x81,0xFF,0x18
};
const uint8_t levelBAT_Tb[] = {
0xFF,0x81,0xBD,0xBD,0xBD,0x81,0xBD,0xBD,0xBD,0x81,0x81,0x81,0x81,0x81,0xFF,0x18
};

// const uint8_t rssi[] = {
// 0x03,0x03,0x03,0x00,0x00,0x0F,0x0F,0x0F,0x00,0x00,0x1F,0x1F,0x1F,0x00,0x00,0x00,
// 0x7F,0x7F,0x7F,0x00,0x00,0xFF,0xFF,0xFF
// };

const uint8_t rssi[] = { 
    0xC0,0x00,0xE0,0xE0,0x00,0xF0,0xF0,0x00,0xF8,0xF8,0x00,0xFC,0xFC,0x00,0xFE,0xFE
};
const uint8_t station_icon[] = {
    0xFE,0x82,0xBA,0x82,0xBA,0x82,0xBA,0x82,0xBA,0xAA,0xAA,0xAA,0xAA,0xBA,0x82,0xFE
};
const uint8_t clock_icon[] = {
    0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x9A,0x92,0x92,0x44,0x38,0x00,0x00,0x00,0x00
};
void Tim4_config(void){
    TIM4->PSCR = (uint8_t)TIM4_PRESCALER_128;
    TIM4->ARR = (uint8_t)125 - 1;

    /* Enable the Interrupt sources */
    TIM4->IER |= (uint8_t)TIM4_IT_UPDATE;

    /* Clear the flags (rc_w0) clear this bit by writing 0. Writing �1� has no effect*/
    TIM4->SR1 = (uint8_t)(~TIM4_FLAG_UPDATE);

    /*Enables the TIM4 peripheral*/
    TIM4->CR1 |= TIM4_CR1_CEN;

	enableInterrupts(); 
}
void configADC(void){
    ADC1->CSR  = ADC1_CSR_RESET_VALUE;
    ADC1->CR1  = ADC1_CR1_RESET_VALUE;
    ADC1->CR2  = ADC1_CR2_RESET_VALUE;
    ADC1->CR3  = ADC1_CR3_RESET_VALUE;
    ADC1->TDRH = ADC1_TDRH_RESET_VALUE;
    ADC1->TDRL = ADC1_TDRL_RESET_VALUE;
    ADC1->HTRH = ADC1_HTRH_RESET_VALUE;
    ADC1->HTRL = ADC1_HTRL_RESET_VALUE;
    ADC1->LTRH = ADC1_LTRH_RESET_VALUE;
    ADC1->LTRL = ADC1_LTRL_RESET_VALUE;
    ADC1->AWCRH = ADC1_AWCRH_RESET_VALUE;
    ADC1->AWCRL = ADC1_AWCRL_RESET_VALUE;
    /* Clear the align bit */
    ADC1->CR2 &= (uint8_t)(~ADC1_CR2_ALIGN);
    /* Configure the data alignment */
    ADC1->CR2 |= (uint8_t)(ADC1_ALIGN_RIGHT);
    /* Set the single conversion mode */
    ADC1->CR1 &= (uint8_t)(~ADC1_CR1_CONT);

    /* Clear the ADC1 channels */
    ADC1->CSR &= (uint8_t)(~ADC1_CSR_CH);
    /* Select the ADC1 channel */
    ADC1->CSR |= (uint8_t)(ADC1_CHANNEL_4);

    /* Clear the SPSEL bits */
    ADC1->CR1 &= (uint8_t)(~ADC1_CR1_SPSEL);
    /* Select the prescaler division factor according to ADC1_PrescalerSelection values */
    ADC1->CR1 |= (uint8_t)(ADC1_PRESSEL_FCPU_D18);


    /* Enable the ADC1 interrupts */
    ADC1->CSR |= (uint8_t)ADC1_IT_EOCIE;

    /* Enable the ADC1 peripheral */
    ADC1->CR1 |=  ADC1_CR1_ADON;
}
void delay_us(unsigned long int  us) {
  for(;us > 0; us--) nop();
}
void delay_ms(unsigned int  u16Delay)
{
    for(; u16Delay > 0; u16Delay--) delay_us(1000);
}
void BEEP_config(void){
    //--------------------BEEP CONFIG----------------------- */
    BEEP->CSR = BEEP_CSR_RESET_VALUE;
    /* Set a default calibration value if no calibration is done */
    if ((BEEP->CSR & BEEP_CSR_BEEPDIV) == BEEP_CSR_BEEPDIV)
    {
    BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPDIV); /* Clear bits */
    BEEP->CSR |= 0x0B; /*!< Default value when calibration is not done */
    }
    /* Select the output frequency */
    BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPSEL);
    BEEP->CSR |= (uint8_t)(0x80); /*!< Beep signal output frequency equals to 4 KHz */

	// /* Enable the BEEP peripheral */
    // BEEP->CSR |= BEEP_CSR_BEEPEN;

    /* Disable the BEEP peripheral */
    BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPEN);
}
void BEEP_Cmd(FunctionalState NewState)
{
  if (NewState != DISABLE)
  {
    /* Enable the BEEP peripheral */
    BEEP->CSR |= BEEP_CSR_BEEPEN;
  }
  else
  {
    /* Disable the BEEP peripheral */
    BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPEN);
  }
}
void i2c_init(void)
{
	// I2C_DeInit();
	// i2c_init( 100000,0xD0,I2C_DUTYCYCLE_2 , I2C_ACK_CURR ,I2C_ADDMODE_7BIT ,16);
	// I2C_Cmd(ENABLE);

    SDA_1;
	SCL_1;
}
void i2c_start(void)
{
	// /* Check busy flag */
	// while(I2C_GetFlagStatus(I2C_FLAG_BUSBUSY) == SET);
	// /* Generate a START condition */
	// I2C_GenerateSTART(ENABLE);
	// /*Check --EV5 */
	// while(I2C_CheckEvent( I2C_EVENT_MASTER_MODE_SELECT) == ERROR);

    SCL_1;
	DELAYI2C;
	SDA_1;
	DELAYI2C;
	SDA_0;
	DELAYI2C;
	SCL_0;
	DELAYI2C;

}
void i2c_stop(void)
{
	// I2C_GenerateSTOP(ENABLE);

    SDA_0;
	DELAYI2C;
	SCL_1;
	DELAYI2C;
	SDA_1;
	DELAYI2C;
}
uint8_t i2c_write(uint8_t u8Data)
{
	// I2C_SendData(data);
	// /* Write data and test on EV8 and clear it */
	// while(I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTING)== ERROR);
    uint8_t i;
	uint8_t u8Ret;
	
	for (i = 0; i < 8; ++i) {
		if (u8Data & 0x80) {
			SDA_1;
		} else {
			SDA_0;
		}
		DELAYI2C;
		SCL_1;
		DELAYI2C;
		SCL_0;
		// DELAYI2C;
		u8Data <<= 1;
	}
	/*Kiem tra xung thu 9*/
	SDA_0;
	DELAYI2C;

	SCL_1;
	DELAYI2C;
	SCL_0;
	DELAYI2C;
    SDA_1;
	if (SDA_VAL) {
		u8Ret = 0;
	} else {
		u8Ret = 1;
	}
	DELAYI2C;
	return u8Ret;
}
uint8_t i2c_read(uint8_t Ack)
{
	uint8_t u8DataRead = 0;
	uint8_t i;
	SDA_1;
	for (i = 0; i < 8; ++i)
	{
		u8DataRead = u8DataRead << 1;
		SCL_1;
		DELAYI2C;
		if (SDA_VAL)
		{
			u8DataRead = u8DataRead | 0x01;
		}
		DELAYI2C;
		SCL_0;
		DELAYI2C;
	}

	if(Ack){
		SDA_0;
	} else {
		SDA_1;
	}
	DELAYI2C;

	SCL_1;
	DELAYI2C;
	SCL_0;
	DELAYI2C;
	return u8DataRead;
}
uint8_t data_write(uint8_t address, uint8_t addressData, uint8_t num, uint8_t *data)
{
    uint8_t i;
    for(i=0; i< num; ++i)
    {
        i2c_start();
        i2c_write(address);
        i2c_write(addressData++);
        i2c_write(data[i]);
        i2c_stop();
        delay_us(1000);
    }
    return 1;
}
uint8_t data_read(uint8_t address, uint8_t addressData, uint8_t num, uint8_t *data)
{
    uint8_t i;
    i2c_start();
    i2c_write(address);
    i2c_write(addressData);
    
    i2c_start();
    i2c_write(address | 0x01);
    for(i=0; i< num - 1; ++i)
    {
        data[i] = i2c_read(1);
    }
    data[i] = i2c_read(0);
    i2c_stop();
    return 1;
}
uint8_t decimal_to_bcd(uint8_t value)
{
	unsigned char hex;
	hex = (((value / 10) << 4) + (value % 10));
	return hex;
}
void writeTime(uint8_t giay, uint8_t phut, uint8_t gio){
    uint8_t u8Data[3];
    u8Data[0] = decimal_to_bcd(giay);
    u8Data[1] = decimal_to_bcd(phut);
    u8Data[2] = decimal_to_bcd(gio);
    data_write(ADDR_DS13, 0x00, 3, u8Data);
}
void writeDay(uint8_t date, uint8_t month){
    uint8_t u8Data[2];
    u8Data[0] = decimal_to_bcd(date);
    u8Data[1] = decimal_to_bcd(month);
    data_write(ADDR_DS13, 0x04, 2, u8Data);
}
void Write_EEPROM(uint32_t Address, unsigned char Data){
    /* Unlock data memory */
    FLASH->DUKR = (uint8_t)0xAE ; /*!< Second RASS key */ /* Warning: keys are reversed on data memory !!! */ 
    FLASH->DUKR = (uint8_t)0x56 ;  /*!< First RASS key */

    *(PointerAttr uint8_t*) (MemoryAddressCast)Address = Data;

    /* Lock memory */
    FLASH->IAPSR &= (uint8_t)0xF7; /*!< Data EEPROM memory */
}
uint8_t Read_EEPROM(uint32_t Address){
    return(*(PointerAttr uint8_t *) (MemoryAddressCast)Address);
}
void SD1106_sendCom(uint8_t command){
    i2c_start();                // initialize I2C first
    i2c_write(OLED_ADDR);
    i2c_write(OLED_CMD_MODE);   // set command mode
    i2c_write(command);         // send the command bytes
	i2c_stop();  
    // data_write(OLED_ADDR, OLED_CMD_MODE, 1, command);
}
void SD1106_sendInitCom(void){
    SD1106_sendCom(DISPLAYOFF);
    SD1106_sendCom(NORMALDISPLAY);
    SD1106_sendCom(SETDISPLAYCLOCKDIV);
    SD1106_sendCom(0x80);
    SD1106_sendCom(SETMULTIPLEX);
    SD1106_sendCom(0x3f);   //0x3F
    SD1106_sendCom(SETDISPLAYOFFSET);
    SD1106_sendCom(0x00);
    SD1106_sendCom(SETSTARTLINE | 0x00);
    SD1106_sendCom(CHARGEPUMP);
    SD1106_sendCom(0x14);
    SD1106_sendCom(MEMORYMODE);
    SD1106_sendCom(0x00);
    SD1106_sendCom(SEGREMAP);   //A0: le phai, A1: le trai
    SD1106_sendCom(COMSCANDEC); //0xC8: scan from COM(n-1) to COM0 : hien thi o tren, 0xC0 scan from COM0 to COM(n-1) : hien thi o duoi
    SD1106_sendCom(SETCOMPINS);
    SD1106_sendCom(0x12); //0x12
    SD1106_sendCom(SETCONTRAST);
    SD1106_sendCom(0xcf);
    SD1106_sendCom(SETPRECHARGE);
    SD1106_sendCom(0xF1);
    SD1106_sendCom(SETVCOMDETECT);
    SD1106_sendCom(0x40);
    SD1106_sendCom(DISPLAYALLON_RESUME);
    SD1106_sendCom(NORMALDISPLAY);
    SD1106_sendCom(0x2E);   //stop scroll
    SD1106_sendCom(DISPLAYON);
}
void SD1106_clear(void)
{
    for (uint8_t page = 0; page<8; page++){
    SD1106_sendCom(PAGESTARTADDRESS | page);
    SD1106_sendCom(SETLOWCOLUMN | 2);
    SD1106_sendCom(SETHIGHCOLUMN | 0);
    // send as 16 bunches of 8 bytes data in one xmission
    for(uint8_t y=0; y<16; y++){
        i2c_start();  
        i2c_write(OLED_ADDR);
        i2c_write(OLED_DAT_MODE);
        for (uint8_t w=0; w<8; w++) {
            i2c_write(0x00); 
        }
        i2c_stop();
        
    }
	}
}
void SD1106_CUS_PRINT(void){
    // SD1106_printP("CHAO MUNG", 1, 40);
    // SD1106_printP("QUOC KHANH VIET NAM", 3, 10);
    // SD1106_printP("2-9-2024", 5, 40);
    
    // delay_ms(3000);
    for(uint8_t i=0; i<8;++i){
        SD1106_sendCom(PAGESTARTADDRESS | i);
        SD1106_sendCom(SETLOWCOLUMN | 2);
        SD1106_sendCom(SETHIGHCOLUMN | 0);
        // send as 16 bunches of 8 bytes data in one xmission
        i2c_start();  
        i2c_write(OLED_ADDR);
        i2c_write(OLED_DAT_MODE);
        for (uint16_t w=i*128; w < (i+1)*128 ; w++) {
            i2c_write(lacoVietNam[w]); 
        }
        i2c_stop();  
    }

    delay_ms(2000);
    SD1106_clear();

    for(uint8_t i=0; i<8;++i){
        SD1106_sendCom(PAGESTARTADDRESS | i);
        SD1106_sendCom(SETLOWCOLUMN | (32 & 0xf));
        SD1106_sendCom(SETHIGHCOLUMN | ( (32 >> 4) & 0xf) );
        // SD1106_sendCom(SETLOWCOLUMN | 0);
        // SD1106_sendCom(SETHIGHCOLUMN | 0);
        // send as 16 bunches of 8 bytes data in one xmission
        i2c_start();  
        i2c_write(OLED_ADDR);
        i2c_write(OLED_DAT_MODE);
        for (uint16_t w=i*64; w < (i+1)*64 ; w++) {
            i2c_write(mixigamingLogo[w]); 
        }
        i2c_stop();   
    }

    delay_ms(1000);
    SD1106_clear();

}
void print_levelBAT(uint8_t levelBAT ){
    SD1106_sendCom(PAGESTARTADDRESS | 0);
    SD1106_sendCom(SETLOWCOLUMN | (80 & 0xf));
    SD1106_sendCom(SETHIGHCOLUMN | ( (80 >> 4) & 0xf) );
    // send as 16 bunches of 8 bytes data in one xmission
    i2c_start();  
    i2c_write(OLED_ADDR);
    i2c_write(OLED_DAT_MODE);
    if(levelBAT >= 38){
        for (uint8_t w=0; w<sizeof(levelBAT_full); w++) {
            i2c_write(levelBAT_full[w]); 
        }
    } else {
        for (uint8_t w=0; w<sizeof(levelBAT_Tb); w++) {
            i2c_write(levelBAT_Tb[w]); 
        }
    }  
        i2c_stop();
}
void print_rssi(void){
    SD1106_sendCom(PAGESTARTADDRESS | 0);
    SD1106_sendCom(SETLOWCOLUMN | 2);
    SD1106_sendCom(SETHIGHCOLUMN | 0);
    // send as 16 bunches of 8 bytes data in one xmission
    i2c_start();  
    i2c_write(OLED_ADDR);
    i2c_write(OLED_DAT_MODE);
    for (uint8_t w=0; w<sizeof(rssi); w++) {
        i2c_write(rssi[w]); 
    }
}
void station_chanel(void){
    SD1106_sendCom(PAGESTARTADDRESS | 1);
    SD1106_sendCom(SETLOWCOLUMN | 2);
    SD1106_sendCom(SETHIGHCOLUMN | 0);
    // send as 16 bunches of 8 bytes data in one xmission
    i2c_start();  
    i2c_write(OLED_ADDR);
    i2c_write(OLED_DAT_MODE);
    for (uint8_t w=0; w<sizeof(station_icon); w++) {
        i2c_write(station_icon[w]); 
    }
}
void clock_icon_ds(void){
    SD1106_sendCom(PAGESTARTADDRESS | 1);
    SD1106_sendCom(SETLOWCOLUMN | (80 & 0xf));
    SD1106_sendCom(SETHIGHCOLUMN | ( (80 >> 4) & 0xf) );
    // send as 16 bunches of 8 bytes data in one xmission
    i2c_start();  
    i2c_write(OLED_ADDR);
    i2c_write(OLED_DAT_MODE);
    for (uint8_t w=0; w<sizeof(clock_icon); w++) {
        i2c_write(clock_icon[w]); 
    }
}
void SD1106_setContranst(char constrast)
{
    SD1106_sendCom(0x81);
    SD1106_sendCom(constrast);
}
void SD1106_resetDis(void)
{
    SD1106_sendCom(0xAE);   //OLED Off
    SD1106_clear();
    SD1106_sendCom(0xAF);   ////OLED On
}
void SD1106_flipScreen(void)
{
    SD1106_sendCom(0xA0);   //le trai hay phai
    SD1106_sendCom(SETCOMPINS);
    SD1106_sendCom(0x22);
    SD1106_sendCom(COMSCANINC);
}
//Ngang 27 ky tu, 5*8, Doc 8 hang
void SD1106_printP(char* p, uint8_t PAGES, uint8_t Column)
{
    SD1106_sendCom(PAGESTARTADDRESS | PAGES);
    SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
    SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
    i2c_start();  
    i2c_write(OLED_ADDR);
    i2c_write(OLED_DAT_MODE);
    while(*p){
        uint16_t offset = *p - 32;
        offset += (offset << 2) ;
        i2c_write(0x00);   
        for (uint8_t w=0; w<5; w++) {
            i2c_write(OLED_FONT[offset++]); 
        }
        p++;    
    }
    i2c_stop();
}
void SD1106_print_one_num(uint8_t so, uint8_t PAGES, uint8_t Column)
{
    SD1106_sendCom(PAGESTARTADDRESS | PAGES);
    SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
    SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
    i2c_start();
    i2c_write(OLED_ADDR);					// start transmission to OLED
    i2c_write(OLED_DAT_MODE);
    uint16_t offset = so + 16;					
    offset += offset << 2;					// -> offset = so * 5
    i2c_write(0x00);                       // print spacing between characters
    for(uint8_t i=5; i; i--) i2c_write(OLED_FONT[offset++]); // print character
    i2c_stop();
}
void SD1106_printNum(unsigned int Number, uint8_t PAGES,  uint8_t Column)
{
    unsigned char mang[] = {0, 0, 0, 0, 0};
	unsigned char count = 0;
    unsigned int offset;
	if (Number == 0)   //In ra so 0 khi Number = 0
	{
		mang[0] = 0;
		count = 1;
	}
	while (Number != 0)
	{
		mang[count] = Number % 10;
		Number = Number / 10;
		++count;
	}
    SD1106_sendCom(PAGESTARTADDRESS | PAGES);
    SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
    SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
    i2c_start();
    i2c_write(OLED_ADDR);					// start transmission to OLED
    i2c_write(OLED_DAT_MODE);
    while (count != 0)
	{
		offset = mang[count - 1] + 16;
		offset += offset << 2;
		i2c_write(0x00);
		for (unsigned char i = 5; i; i--)
		{
			i2c_write(OLED_FONT[offset++]);
		}
		--count;
	}
	i2c_stop();
}
void SD1106_printBigNum(uint8_t Num, uint8_t Column){
    uint16_t offset = (Num << 2) + Num;			
    for(uint8_t i=3;  i< 8; ++i){
        SD1106_sendCom(PAGESTARTADDRESS | i);
        SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
        SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
        i2c_start();
        i2c_write(OLED_ADDR);					// start transmission to OLED
        i2c_write(OLED_DAT_MODE);
        for(uint8_t z=0; z<3; ++z){
            if( ((OLED_FONT_BIG[offset]) >> (2 - z)) & 0b1 ) {
                for(uint8_t t=5; t; t--) i2c_write(0xff); // print character
            } else {
                for(uint8_t t=5; t; t--) i2c_write(0x00); // print character
            }
            
        }
        offset++;
        i2c_stop();
    }    
}
void SD1106_printBigPoint(uint8_t Column){		
    for(uint8_t i=3;  i< 8; ++i){
        SD1106_sendCom(PAGESTARTADDRESS | i);
        SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
        SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
        i2c_start();
        i2c_write(OLED_ADDR);					// start transmission to OLED
        i2c_write(OLED_DAT_MODE);
        // i2c_write(0x00);
        if(i == 4 | i == 6){
                for(uint8_t t=5; t; t--) i2c_write(0xff); // print character
            } else {
                for(uint8_t t=5; t; t--) i2c_write(0x00); // print character
            }
        i2c_stop();
    }
}

void SD1106_printBigLine(uint8_t Column){		
    for(uint8_t i=3;  i< 8; ++i){
        SD1106_sendCom(PAGESTARTADDRESS | i);
        SD1106_sendCom(SETLOWCOLUMN | (Column & 0xf));
        SD1106_sendCom(SETHIGHCOLUMN | ( (Column >> 4) & 0xf) );
        i2c_start();
        i2c_write(OLED_ADDR);					// start transmission to OLED
        i2c_write(OLED_DAT_MODE);
        // i2c_write(0x00);
        if(i == 5){
                for(uint8_t t=5; t; t--) i2c_write(0xff); // print character
            } else {
                for(uint8_t t=5; t; t--) i2c_write(0x00); // print character
            }
        i2c_stop();
    }
}